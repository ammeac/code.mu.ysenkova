/*
p {
	color: #ff7463;
}
*/
h1 {
    color: green;
}
h2 {
    color: blue;
}
h3 {
    color: red;
}
/*
td {
	width: 200px;
	height: 100px;
}
td {
	width: 400px;
	height: 300px;
}
p {
	text-align: right;
}
p {
	text-align: center;
}
th {
	text-align: left;
}

table {
	width: 400px;
}
p {
	text-align: justify;
	width: 300px;
}
h2 {
	font-weight: normal;
}
p {
	font-weight: bold;
}
td {
	width: 500px;
	height: 300px;
}
p {
	font-style: italic;
}
h1 {
	font-size: 50px;
}
h2 {
	font-size: 40px;
}
h3 {
	font-size: 30px;
}
p {
	font-family: "Courier New";
}
p {
	font-size: 30px;
	line-height: 15px;
	text-align: justify;
	width: 400px;
}
p {
	font-size: 30px;
	line-height: 5;
	text-align: justify;
	width: 400px;
}
	*/
#ПРАКТИЧЕСКИЕ
/*
p {
	font: 13px/20px Times New Roman;
}
p {
	font: bold 300px/40px red Arial;
}

p {
	font: bold italic 40px/50px/60px Arial;

}
#красная_строка 
p {
	text-indent: 50px;
	text-align: justify;
	width: 400px;
}
#подчеркниж
p {
	text-decoration: underline;
}
#верхподчерк
p {
	text-decoration: overline;
}
	*/
#зачерк
p {
	text-decoration: line-through;
    color: green
}
/*
a {
	text-decoration: none;
}

h1 {
	font: Times new roman; 
	color: blue ;
	}
	h2 {
		color: green ;
	}
	p {
		font: 15px Arial;
		text-indent: 2em;
	  margin: 0;
	
	}
	i {
		color: green;
	}
	
	h1, h2, h3 {
		text-align: center;
	}
	
	h1, h2, h3 {
		text-align: center;
		font-size: 16px;
	}
	h2 {
		color: blue;
	}
	h3 {
	
		color: red;
	}
	h1, h2, h3 {
		text-align: center;
		font-size: 16px;
		color: red;
	}
		#53
	ul li {
	color: red;
	}
	p li {
	color: green;
	}

	p b i {
	color: red; 
	}
	*/

/*54
 i b {
color: red;
 }
#55
 .odd {
color: red;
}
 .eve {
color: green;
}

.eee {
color: red;
}

#56 */
.xxx {
font-size: 30px;
}
/*
#57 */
.block1 {
	color: red;
}
.block2 {
	color: green;
}
.block3 {
	color: blue;
}

.bloc  {
	color: red;
}
.lox {
	color: green;
}
/* 
#58
//1
.eee {
	font-size: 20px;
}
.zzz {
	font-size: 30px;
}
.eee, .zzz {
	line-height: 1.5;
	font-family: Arial;
}
//2
.eee {
	font-size: 20px;
}
.zzz {
	font-size: 30px;
}
.ggg {
	font-size: 35px;
}
.eee, .zzz, .ggg {
	text-align: center;
	font-family: Arial;
}
*/
h2.header {
	font-size: 40px;
}
h3.header {
	font-size: 30px;
}

.eee i {
	color: red;
}
/*61*/
.eee .bbb {
	color: red;
}
.eee h2 {
	color: red;
}
.eee h2.bbb {
	color: red;
}
.eee h3.bbb {
	color: red;
}
.eee p.bbb {
	color: red;
}
.eee .bbb .kkk {
	color: red;
}
/*62*/
p.bbb {
	color: red;
}

p .bbb {
	color: red;
}

.eee p.bbb {
	color: red;
}

.eee p .bbb {
	color: red;
}
/*63
1*/

.success {
	color: green;
}
.error {
	color: red;
}
.large {
	font-size: 30px;
}
.small {
	font-size: 20px;
}
/*2*/
.big {
	font-size: 40px;
}
.cow {
	color: grey;
}
.bl {
	text-decoration: underline;
}
/*64*/

#elem1 {
	color: red;
}
#elem2 {
	color: green;
}
#elem3 {
	color: blue;
}
/*65*/ 

#blck {
	background-color: lightblue;
	padding: 10px;
	margin-bottom: 20px;
  }
  
.text {
	background-color: lightgreen;
	padding: 10px;
	margin-bottom: 20px;
  }
  
  /*66*/

#elem h2 {
	color:darkslategrey;
  }

#elem .text {
	color:brown;
  }

#elem p.text {
	color:bisque;
}

#elem li.text {
	color:cadetblue;
}

/*67*/

.eee.zzz.ccc {
	color:chocolate;
}

/*68*/

.bbb.zzz {
	color: red;
}

h2.bbb.zzz {
	color: red;
}

#elem.bbb {
	color: red;
}

#elem.bbb.zzz {
	color: red;
}

h2#elem.bbb {
	color: red;
}

/*69*/

h2.zzz {
	color: red;
}

h2 .zzz {
	color: red;
}

.bbb.zzz {
	color: red;
}

.bbb .zzz {
	color: red;
}

.bbb.zzz.xxx {
	color: red;
}

.bbb .zzz.xxx {
	color: red;
}

.bbb.zzz .xxx {
	color: red;
}

.bbb .zzz .xxx {
	color: red;
}

#elem.bbb {
	color: red;
}

#elem .bbb {
	color: red;
}

/*70 упрощение кода

#block h1, #block h2 {
	text-align: center;
}

#block h1, #block h2 {
	text-align: center;
	font-size: 30px;
  }

  ///71
!1
  #block h1, #block h2, #block h3 {
	text-align: center;
	font-size: 16px;
}
#block h2 {
	color: blue;
}
#block h3 {
	color: red;
}

!2
#block h1.eee, #block h2.zzz {
	text-align: center;
}
	#block h1.eee {
	font-size: 30px;
}
#block h2.zzz {
	font-size: 20px;
}

!3
.xxx .kkk, .eee h2.zzz, #eee h2 {
	text-align: center;
}

!4
.eee h2.zzz, .xxx {
	text-align: center;
}

72

div p {
	color:aquamarine;
  }

div h2 {
	color:blueviolet;
  }
  
#block p {
	color:blue;
  }

  #block h2 {
	color:chartreuse;
  }

.bbb {
	color:rgb(216, 117, 36)
}

#block .bbb {
	color:crimson;
}

.bbb p {
	color:bisque;
}

.bbb h2 {
	color:azure;
}

#block .bbb p {
	color:coral;
}

.bbb, .xxx {
	color:cadetblue;
}

.bbb p, .xxx h2 {
	color: gold;
}

#block p.bbb, #block p.xxx {
	color:darkslateblue;
}

.fff {
	color:forestgreen;
}

.fff p {
	color:deeppink;
}

#block p.fff {
	color:darkolivegreen;
}

.fff .bbb {
	color:indigo;
}

.fff h2.bbb {
	color:aliceblue;
}
*/

/*73 абзацам задается 20,
 а потом 30.
 Вторая запись переопределит первую
 и абзацы станут 30px.

 74 - h2 размер 20 пикселей, стиль италик,цвет красный.

 77 */

 #elem + li {
	color:aquamarine;
  }

.elem + li {
	color:brown;
  }
/*78*/
  #elem ~ li {
	color:cornflowerblue;
  }
/*79*/
  main > * > p {
	color:coral;
  }

  /*80

  title {
	color:chartreuse;
  }

p, title {
	color:cyanp;
}

p, title="hello" {
	color:red;
  }

  a, href="http://" {
	color:blue;
  }

  ahref=".html" {
	color:yellow;
  }

  p, title="hello" {
	color:violet;
  }

  p, class="top-" {
	color:darkgoldenrod
  }

  */

/*82

a:link {
	color:blue;
}
a:hover.link {
	color:red;
	text-decoration: none;
}
a:active {
	color:black;
}
a:visited {
	color:green;
	}
	
84

a:link, a:active, a:visited{
	color:blue;
	text-decoration: none;
}
a:hover.link {
	color:red;
}
*/

/*85

a {
	color: red;
}
a:hover {
	text-decoration: none;
}
	

/*86*/

a.zzz {
	color: red;
}
a.zzz:hover {
	text-decoration: none;
}

#block a.zzz {
	color: red;
}
#block a.zzz:hover {
	text-decoration: none;
}

.ammeac a.zzz {
	color: red;
}
.ammeac a.zzz:hover {
	text-decoration: none;
}

/*88*/

p:first-of-type {
	color: red;
}

h2:nth-of-type(odd) {
	color: red;
}

div {
	border: 1px dashed black;
	padding: 15px;
	margin-bottom: 10px;
}
h2:only-of-type {
	color: red;
}

/*89*/

.elem {
	color:blueviolet;
}

#elem {
	color:chocolate;
}

.elem {
	color:hotpink;
}
/*90*/
#elem {
	width: 300px;
	height: 100px;
	color: white;
	background-color: orange;
}

/*91

#elem {
	border-width: 3px;   
	border-style: solid;  
	border-color: red;   
	width: 300px;
	height: 100px;
}

92 сполшная 

#elem {
	border-width: 1px;
	border-style: solid;
	border-color: black;
	width: 300px;
	height: 100px;
}

93 точечная

#elem {
	border-width: 1px;
	border-style: dotted;
	border-color: black;
	width: 300px;
	height: 100px;
}

94 граница в виде тире

#elem {
	border-width: 1px;
	border-style: dashed;
	border-color: black;
	width: 300px;
	height: 100px;
}
 
95 выпуклая граница
#elem {
	border-width: 3px;
	border-style: ridge;
	border-color: black;
	width: 300px;
	height: 100px;
}

96 двойная граница
#elem {
	border-width: 5px;
	border-style: double;
	border-color: black;
	width: 300px;
	height: 100px;
}

97 свойства сокращения для границы
#elem {
	border: 1px solid red;
	width: 300px;
	height: 100px;
}

98 отдельные стороны границ
лево
#elem {
	width: 300px;
	height: 100px;
	border-left: 1px solid red;
}
право и лево
#elem {
	width: 300px;
	height: 100px;
	border-left: 1px solid red;
	border-right: 1px solid red;
}
	задание
#elem {
	width: 300px;
	height: 100px;
	border-left: 1px solid yellow;
	border-right: 1px solid green;
	border-bottom: 1px solid red;
	border-top: 1px solid blue;
}

99 скругление границ

#elem {
	width: 300px;
	height: 100px;
	border: 1px solid red;
	border-radius: 10px;
}

100 скругление границ фонв
#elem {
	border-radius: 20px;
	width: 300px;
	height: 100px;
	background-color: #e4f1ed;
}

101 созд круга
#elem {
	width: 100px;
	height: 100px;
	border-radius: 50px;
	border: 1px solid green;
}

103 четыре занчение скругления для разных углов

#elem {
	width: 300px;
	height: 100px;
	border: 1px solid red;
	border-radius: 10px 20px 30px 40px;
}

104 два значения скругления для разнфх углов
Если задано два значения, 
то первое значение задает скругление для для верхнего
левого и нижнего правого, второе - верхнего правого
и нижнего левого углов:
#elem {
	width: 300px;
	height: 100px;
	border: 1px solid red;
	border-radius: 10px 40px;
}

105 три значения скругления для разных углов
Если задано три значения,
то первое значение задает скругление для
верхнего левого угла, второе - одновременно 
для верхнего правого и нижнего левого,
а третье - для нижнего правого угла:
#elem {
	width: 300px;
	height: 100px;
	border: 1px solid red;
	border-radius: 10px 20px 30px;
}

106 Скругленные уголки в процентах 

#elem {
	width: 200px;
	height: 200px;
	border: 1px solid red;
	border-radius: 10%;
}

107 Создание круга при скруглении в процентах 

#elem {
	width: 200px;
	height: 200px;
	border: 1px solid red;
	border-radius: 50%;
}

108

#elem {
	background-image: url("bg.png");
	width: 400px;
	height: 300px;
	border: 3px solid black;
}

109
№1
#elem {
	background-repeat: no-repeat;
	background-image: url("bg.png");
	width: 400px;
	height: 300px;
	border: 1px solid black;
}

№2
#elem {
	background-repeat: no-repeat;
	background-image: url("bg.png");
	width: 300px;
	height: 500px;
	border: 1px solid black;
}
*/ /*МАРКЕРЫ РАЗНЫЕ*/
/*112

ul {
	list-style-type: square;
}



ul {
	list-style-type: circle;
}

114*/

ul {
	list-style-type: disc;
}

/*115
ul {
	list-style-type: none;
}
*/
/*117*/
ol {
	list-style-type: lower-roman;
}
/*118
ol {
	list-style-type: upper-roman;
}
лат буквы
ol {
	list-style-type: lower-alpha;
}
заглавные лат буквы
ol {
	list-style-type: upper-alpha;
}
строч греческие буквы
ol {
	list-style-type: lower-greek;
}
числа с нулем впереди для списков
ol {
	list-style-type: decimal-leading-zero;
}
	*/
/*123*/
	#parent {
		width: 300px;
		border: 1px solid red;
	}
	#child {
		height: 100px;
		border: 1px solid green;
	}

/*124 Отступы margin для раз сторон

#parent {
	width: 300px;
	border: 1px solid red;
}
#child {
	margin-top:    10px; /* сверху 
	margin-right:  20px; /* справа 
	margin-bottom: 30px; /* снизу 
	margin-left:   40px; /* слева 
	
	height: 100px;
	border: 1px solid green;
}
*/

/*126 етыре значения в свойстве margin 

#parent {
	width: 300px;
	border: 1px solid red;
}
#child {
	height: 100px;
	border: 1px solid green;
	margin: 10px 20px 30px 40px;
}
	*/

	/*127 Два значения в свойстве margin

	#parent {
		width: 300px;
		border: 1px solid red;
	}
	
	#child {
		height: 100px;
		border: 1px solid green;
		margin: 40px 20px;
	}
*/

/*128 Три значения в свойстве margin

#parent {
	width: 300px;
	border: 1px solid red;
}

#child {
	height: 100px;
	border: 1px solid green;
	margin: 10px 20px 30px;
}
	*/

/*129 Работа с отступами padding и для задания 131*/

#elem {
	width: 300px;
	border: 1px solid red;
	text-align: justify;
}

/* теперь заданим 30 пикселей для всех стрн
 #elem {
	padding: 30px;
	width: 300px;
	border: 1px solid red;
	text-align: justify;
} */

/*130 Отступы padding для разных сторон

#elem {
	padding-top:    10px; /* сверху 
	padding-right:  20px; /* справа 
	padding-bottom: 30px; /* снизу 
	padding-left:   40px; /* слева 
	
	width: 300px;
	border: 1px solid red;
	text-align: justify;
}
*/

/* 132 Работа с отступами padding 

#elem1 {
	width: 100px;
	height: 100px;
	background: #f1f1f1;
	margin-bottom: 20px;
}

#elem2 {
	padding: 25px;  задаем отступы 
	width: 100px;
	height: 100px;
	background: #f1f1f1;
}

/*133 Влияние границы на расширение элементов*/

#elem1 {
	width: 100px;
	height: 100px;
	background: #f1f1f1;
	margin-bottom: 20px;
}

#elem2 {
	width: 100px;
	height: 100px;
	background: #f1f1f1;
	border: 10px solid green;  /* задаем границу */
}

/*Влияние padding и границы на расширение элементов*/

#elem1 {
	width: 100px;
	height: 100px;
	background: #f1f1f1;
	margin-bottom: 20px;
}

#elem2 {
	width: 100px;
	height: 100px;
	background: #f1f1f1;
	padding: 25px; /* задаем отступы */
	border: 10px solid green;  /* задаем границу */
}

/*135 Отмена расширения элементов

#elem1 {
	width: 100px;
	height: 100px;
	background: #f1f1f1;
	margin-bottom: 20px;
}

#elem2 {
	width: 100px;
	height: 100px;
	background: #f1f1f1;
	padding: 25px; /* задаем отступы 
	border: 10px solid green;  /* задаем границу 
	box-sizing: border-box;  /* убираем расширение 
}
	*/

/*137 Ширина и высота блочного элемента 

div {
	width: 100px;
	height: 100px;
	border: 1px solid red;
}

138 Если у блочного элемента не задана ширина,
то он автоматически займет по ширине
все доступное пространство:

div {
	height: 100px;
	border: 1px solid red;
}

139 Высота блочного элемента
Если у блочного элемента не задана высота,
то его высота сформируется содержимым:

div {
	width: 100px;
	border: 1px solid red;
}

140 Высота блочного элемента без содержимого
Если содержимого в блочном элементе нет,
то мы увидим слипшуюся границу:
div {
	width: 100px;
	border: 1px solid red;
}

141 Несколько блочных элементов рядом
в столбик
div {
	width: 100px;
	height: 100px;
	margin-bottom: 20px;
	border: 1px solid red;
}

143 Ширина и высота строчного элемента ДЛЯ SPAN
Ширина и высота строчного элемента всегда
ограничены его текстом.
Даже если задать свойства width и height
 для строчного элемента они не сработают:

 span {
	width: 100px;
	height: 100px;
	border: 1px solid red;
}

144 Несколько строчных элементов рядом

Если расположить несколько строчных элементов рядом,
то они выстроятся в ряд:

span {
	border: 1px solid red;
}

145 Отступы между строчными элементами
Эти отступы представляют собой
банальные пробелы между словами текста.
Убедится в этом можно,
если в HTML коде написать эти теги без пробелов:

span {
	border: 1px solid red;
}

147  Работа со свойством display 
можно сменить модель с помощью свойства display.
С помощью значения block данного свойства элемент
можно сделать блочным,
а с помощью значения inline - строчным.

Давайте сделаем так, чтобы теги span вели себя как
блочные элементы:
span {
	display: block;
	width: 100px;
	height: 100px;
	border: 1px solid red;
	margin-bottom: 20px;
}

 а теперь div как строчные:

 div {
	display: inline;
	width: 100px;
	height: 100px;
	border: 1px solid red;
}

149 Ширина и высота строчно-блочного элемента
Строчно-блочного элементу можно задать ширину
и высоту, подобно блочным элементам:

span {
	width: 100px;
	height: 100px;
	border: 1px solid red;
	display: inline-block;
}

150 Ширина строчно-блочного элемента

Если у строчно-блочного элемента не задана ширина,
то его ширина сформируется содержимым,
подобно строчным элементам:

span {
	height: 100px;
	border: 1px solid red;
	display: inline-block;
}

151 Высота строчно-блочного элемента
Если у строчно-блочного элемента не задана высота,
то его высота сформируется
содержимым, подобно строчным элементам:

span {
	width: 100px;
	border: 1px solid red;
	display: inline-block;
}

152

Несколько строчно-блочных элементов рядом
Если расположить несколько строчно-блочных
элементов рядом,
то они выстроятся в ряд, подобно строчным элементам:

span {
	width: 100px;
	height: 100px;
	margin-bottom: 20px;
	border: 1px solid red;
	display: inline-block;
}
	задание
div {

	margin-bottom: 20px;
	border: 1px solid red;
	display: inline;
	width: 100px;
	height: 100px;
}

153
Выравнивание блочных элементов
Свойство margin применяется не только для
задания отступов, но и для центрирования блочных
элементов. Для этого правый и левый отступ следует
задать в значение auto.

В примере ниже внутренний блок станет по центру:

.parent {
	border: 1px solid red;
}

.child {
	height: 100px;
	width: 200px;
	border: 1px solid green;
	margin: 10px auto;
}

Если нам нужны разные верхний и нижний отступ margin,
то можно написать вот так:

.child {
	margin: 30px auto 10px auto;
}

Можно переписать и через три значения: первое задаст
верхний отступ, третье - нижний, а второе задаст
значение auto для правого и левого отступов:

.child {
	margin: 30px auto 10px;
}

задание

.parent {
	border: 1px solid red;
}

.child {
	margin: 30px auto 10px;
}

.child2 {
	margin: 40px auto 10px;
}

.child3 {
	margin: 50px auto 10px;
}

154 Выравнивание блочного элемента с отступом слева
Можно, однако, поставить только левый отступ.
В этом случае элемент получит максимально возможный
отступ слева и займет крайнее правое положение:
.parent {
	padding: 10px 0;
	border: 1px solid red;
}
.child {
	margin-left: auto; задаем автоматический левый отступ
		height: 100px;
		width: 200px;
		border: 1px solid green;
	}

155 Выравнивание блочного элемента с отступом справа
.parent {
	padding: 10px 0;
	border: 1px solid red;
}
.child {
	margin-left: auto;
	margin-right: 20px; задаем правый отступ 
		height: 100px;
		width: 200px;
		border: 1px solid green;
	}

157 Центрирование строчных элементов
текст в границе, в границе
.parent {
	text-align: center;
	padding: 10px 0;
	border: 1px solid red;
}
.child {
	border: 1px solid green;
}

158 Центрирование нескольких строчных элементов
текст в блоке, несколько в строку, в общем блоке
.parent {
	text-align: center;
	padding: 10px 0;
	border: 1px solid red;
}
.child {
	border: 1px solid green;
}

задание

.parent {
	padding: 10px 0;
	border: 1px solid red;
}

.child {
	border: 1px solid red;
}

159 Выравнивание строчных элементов по правому краю
текст в блоке по правому краю, в границах
.parent {
	text-align: right;
	padding: 10px 0;
	border: 1px solid red;
}
.child {
	border: 1px solid green;
}

задание

.parent {
text-align: right;
	padding-right: 10px;
	border: 1px solid red;
}
.child {
	border: 1px solid green;
}
161 Центрирование строчно-блочных элементов

.parent {
  padding: 10px 0;
  border: 1px solid red;
  text-align: center;  Центрирование по горизонтали 
}

.child {
  display: inline-block;  Преобразование в строчно-блочный элемент 
  padding: 10px;
  border: 1px solid green;
  margin: 0 5px; Горизонтальный margin в 5px 
}


162 Выравнивание строчно-блочных
элементов по правому краю

.parent {
	text-align: center;
	padding: 10px 0;
	border: 1px solid red;
}
.child {
	display: inline-block;
	padding: 10px 20px;
	border: 1px solid green;
}

163 Флекс элементы

Флекс элементы, подобно блочным
могут иметь ширину и высоту, margin и padding.
Однако, в отличие от блочных,
по умолчанию флекс элементы выстраиваются
в ряд внутри своего родителя.

.parent {
	display: flex;  потомки будут флекс 
		элементами 
		width: 300px;
		height: 200px;
		border: 1px solid red;
	}
	.child {
		width: 50px;
		height: 50px;
		border: 1px solid green;
	}

164 Высота родителя флекс элементов
Если родителю флекс элементов не задана высота,
то по высоте он будет растягиваться своим
содержимым, то есть высотой потомков:

.parent {
	display: flex;
	width: 300px;
	border: 1px solid red;
}
.child {
	width: 50px;
	height: 50px;
	border: 1px solid green;
}

165 Ширина родителя флекс элементов
Если родителю флекс элементов не задана ширина,
то по ширине он займет все доступное место:

.parent	{
	display: flex;
	border: 1px solid red;
}
.child {
	width: 50px;
	height: 50px;
	border: 1px solid green;
}

166 Строчно-блочный родитель флекс элементов 

Вместо значения flex для свойства display родителю
можно поставить значение inline-flex.
В этом случае этот родитель будет вести себя,
как строчно-блочный элемент.

.parent	{
	display: inline-flex;
	border: 1px solid red;
}
.child {
	width: 50px;
	height: 50px;
	border: 1px solid green;
}

167 Отступы padding родителя флекс элементов

.parent	{
	display: inline-flex;
	padding: 10px;
	border: 1px solid red;
}
.child {
	width: 50px;
	height: 50px;
	border: 1px solid green;
}

168 Отступы margin потомкам

.parent	{
	display: inline-flex;
	border: 1px solid red;
}
.child {
	margin: 10px;
	width: 50px;
	height: 50px;
	border: 1px solid green;
}

170 Выравнивание флекс элементов по центру

Значение center, установленное в свойстве
justify-content, позволяет выровнять элементы
по центру:

.parent {
	display: flex;
	justify-content: center;
}

171 Выравнивание флекс элементов по родителю

Значение space-between, заданное в свойстве
justify-content, позволяет равномерно распределить
элементы по родителю. При этом расстояние между
ними рассчитывается автоматически.
Первый элемент будет прижат к левому краю,
а последний - к правому.

.parent {
	display: flex;
	justify-content: space-between;
}

172 Выравнивание флекс элементов по родителю с отступами 

Значение space-around в свойстве justify-content
задает первому и последнему флекс элементам отступ
от края родителя.

С первого взгляда может показаться,
что расстояние между элементами и между крайними
элементами и родителем будут равны, однако, это не
так - расстояние между элементами будет в 2 раза
больше, чем между родителем и крайним элементом.

.parent {
	display: flex;
	justify-content: space-around;
}

173 Выравнивание флекс элементов
по родителю с равными отступами

Поведение значения space-around чаще всего не то,
которое вам хотелось бы.
Чаще всего нам нужно сделать так,
чтобы все указанные промежутки были равны.

Для этого придумано значение space-evenly,
которое и сделает то, что нам нужно

.parent	{
	display: flex;
	justify-content: space-evenly;
}

174 Абсолютное позиционирование элементов

№практические
1

2

3

4

175 Относительное позиционирование элементов

#elem1 {
	width: 100px;
	height: 100px;
	margin-bottom: 20px;
	background-color: #FF8888;
}
#elem2 {
position: relative;
	top: -40px;
	left: 20px;
	width: 100px;
	height: 100px;
	margin-bottom: 20px;
	background-color: #7E89EB;
}
#elem3 {
position: relative;
	top: -60px;
	left: 40px;
	width: 100px;
	height: 100px;
	margin-bottom: 20px;
	background-color: #4DEE99;
}

176 Позиционирование относительно родителя

#parent {
	width: 500px;
	height: 300px;
	margin: 0 auto;
	border: 1px solid red;
}

#child {
	position: absolute;
	top: 20px;
	left: 20px;
	
	width: 100px;
	height: 100px;
	border: 1px solid green;
}

#child {
	position: absolute;
	top: 40px;
	left: 60px;
	
	width: 100px;
	height: 100px;
	border: 1px solid green;
}

177 Позиционирование относительно абсолютного родителя
#parent {
	position: absolute;
	top: 100px;
	left: 200px;
	
	width: 500px;
	height: 300px;
	border: 1px solid red;
}
#child {
	position: absolute;
	top: 0;
	left: 0;
	
	width: 200px;
	height: 200px;
	border: 1px solid green;
}

178 Абсолютное позиционирование без координат 
#elem1 {
	width: 200px;
	height: 150px;
	border: 1px solid red;
}
#elem2 {
	position: absolute;
	left: 40px;  добавляем 
		позицию по горизонтали 
	
		width: 100px;
		height: 100px;
		margin-left: 10px;
		border: 1px solid green;
	}
	#elem3 {
		width: 50px;
		height: 150px;
		border: 1px solid blue;

#elem1 {
	width: 200px;
	height: 150px;
	border: 1px solid red;
}
#elem2 {
	position: absolute;
	top: 100px;  добавляем 
		позицию по вертикали 
	
		width: 100px;
		height: 100px;
		margin-left: 10px;
		border: 1px solid green;
	}
	#elem3 {
		width: 50px;
		height: 150px;
		border: 1px solid blue;
	}

	179 Центрирование через абсолют

	#elem {
	position: absolute;
	top:    30px;
	right:  30px;
	bottom: 30px;
	left:   30px;
	
	border: 1px solid green;
}
	#elem2 {
	border: 1px solid red;
	position: absolute;
	top:    100px;
	right:  200px;
	bottom: 50px;
	left:   10px;

180 Отрицательные значения при позиционировании

#parent {
	position: relative;
	width: 300px;
	height: 300px;
	margin: 50px auto;
	border: 1px solid red;
}
#child {
	position: absolute;
	top: -50px;
	left: -60px;
	
	width: 50px;
	height: 50px;
	border: 1px solid green;
}

#child {
	position: absolute;
	top: 50px;
	left: 60px;
	
	width: 50px;
	height: 50px;
	border: 1px solid green;
}

181 Фиксированное позиционирование

#elem {
	position: fixed; задаем фиксированное позиционирование 
		*
		top: 30px;
		right: 30px;
		width: 100px;
		height: 100px;
		border: 1px solid green;
	}
	
	#content {
		margin: 0 auto;
		width: 300px;
		text-align: justify;
		font: 16px Arial;
	}
182
Блок на всю ширину экрана
Чтобы фиксированный блок занял всю ширину экрана,
ему нужно задать ширину 100%

#elem {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100px;
	border: 1px solid green;
	background: green;
}

#content {
	margin: 0 auto;
	width: 300px;
	text-align: justify;
}

183 Регулирование наложения элементов по оси Z
Порядок наложения элементов можно регулировать с
 помощью свойства z-index, принимающего своим
 значением целые положительные или отрицательные числа,
 либо ноль. Свойство работает только для элементов,
 у которых значение position задано как absolute,
 fixed или relative.

При использовании данного свойства правило
наложения элементов следующее: выше будет тот
элемент, у которого значение z-index больше.

Давайте поменяем порядок наложения элементов
из предыдущего примера. Для этого первому
элементу поставим z-index больше, чем у второго,
например, вот так:
#elem1 {
	z-index: 2;
}
#elem2 {
	z-index: 1;
}

№1
#elem1 {
	z-index: 1;
}
#elem2 {
	z-index: 2;
}
#elem3 {
z-index: 3;
}
№2
#elem1 {
	z-index: 2;
}
#elem2 {
	z-index: 1;
}
#elem3 {
z-index: 3;
}

185 Нюансы применения отрицательного значения z-index
Если z-index у элемента не задан, то его значение следует
трактовать как 0. Это значит, что элемент со значением
z-index, равным -1, будет ниже элемента без z-index.

Можно переделать пример с нашими двумя элементами
следующим образом: просто задать второму элементу
z-index в значение -1, и он станет под первый элемент:

#elem1 {
	 не задаем z-index 
}
#elem2 {
	z-index: -1;
}

#1

#elem1 {
	z-index: -1;
}
#elem2 {
	
}
#elem3 {
	z-index: -1;
}

186 Введение в свойство float

Пусть у нас есть див с каким-то длинным текстом.
Давайте вставим в начало этого текста картинку:

div {
	width: 400px;
	text-align: left;
}

div {
	width: 400px;
	text-align: justify;
}
img {
	float: right;
}

187 Проникновение плавающих элементов через теги
Пусть теперь у нас текст размещен в абзацах,
а картинка, которой задано свойство float находится
над этими абзацами. В этом случае все будет
работать, как и работало - наличие других тегов
не мешает обтеканию:

div {
	width: 400px;
	border: 1px solid red;
	text-align: justify;
}
img {
	float: left;
}

188 Сочетание float и margin
Сейчас наш текст прижат к картинке
с левой стороны. Давайте попробуем
немного отодвинуть этот текст.
Для этого зададим нашим абзацам левый
margin в 30px, а диву-родителю - красную границу.

Неожиданно вправо отступит тольк
тот текст, который прилегает
в диву-родителю, а текст,
прилегающий к картинке - не отодвинется:

div {
	width: 400px;
	border: 1px solid red;
	text-align: justify;
}
p {
	margin-left: 30px;
}
img {
	float: left;
}

Чтобы понять, почему это так,
добавим абзацам зеленую границу:
div {
	width: 400px;
	border: 1px solid red;
	text-align: justify;
}
p {
	margin-left: 30px;
	border: 1px solid green;
}
img {
	float: left;
}

Как мы видим, на самом деле абзацы
отодвигаются от левого края, но не от
картинки, а от дива-родителя. Чтобы
рассмотреть подробнее, давайте
добавим еще и полупрозначность
картинке через свойство opacity:

div {
	width: 400px;
	border: 1px solid red;
	text-align: justify;
}
p {
	margin-left: 30px;
	border: 1px solid green;
}
img {
	float: left;
	opacity: 0.5;
}

Вот теперь точно видно, что реакция
на margin-left есть, только абзацы 
на самом деле размещены под картинкой.
Давайте уберем отступ, оставив при этом
полупрозрачность картинке:

div {
	width: 400px;
	border: 1px solid red;
	text-align: justify;
}
p {
	border: 1px solid green;
}
img {
	float: left;
	opacity: 0.5;
}

Вот так на самом деле выглядят наши абзацы
 их текст отодвинут картинкой, но физически
 абзацы лежат под картинкой, это видно по
 границе, которая начинается от левого края
 дива-родителя.

Давайте вернем margin и засунем картинку в
первый абзац:

div {
	width: 400px;
	border: 1px solid red;
	text-align: justify;
}
p {
	margin-left: 30px;
	border: 1px solid green;
}
img {
	float: left;
	opacity: 0.5;
}

189 Сочетание float и padding
Давайте опять поставим картинку
над абзацами, оставив им при этом левый padding.
В этом случае padding отодвинет только тот текст,
который прилегает слева к диву-родителю,
а не к нашей картинке:

div {
	width: 400px;
	border: 1px solid red;
	text-align: justify;
}
p {
	margin-left: 30px;
	padding-left: 30px;
	border: 1px solid green;
}
img {
	float: left;
	opacity: 0.5;
}

А теперь положим картинку в первый абзац 
она будет двигаться вправо вместе с текстом абзацев:

div {
	width: 400px;
	border: 1px solid red;
	text-align: justify;
}
p {
	margin-left: 30px;
	padding-left: 30px;
	border: 1px solid green;
}
img {
	float: left;
	opacity: 0.5;
}

190 Отступы для картинки при сочетании float и padding 
Давайте добавим правый margin 
в этом случае текст действительно отодвинется
от правого края картинки:

div {
	width: 400px;
	border: 1px solid red;
	text-align: justify;
}
p {
	border: 1px solid green;
}
img {
	float: left;
	margin-right: 30px;
	opacity: 0.5;
}

Интересный эффект получится,
если добавить еще и margin абзацам
сами абзацы отодвинутся от левого края
дива-родителя, при этом текст в них
по-прежнему будет отодвинут от правого
края картинки, так как ей задан правый margin:

div {
	width: 400px;
	border: 1px solid red;
	text-align: justify;
}
p {
	margin-left: 30px;
	border: 1px solid green;
}
img {
	float: left;
	margin-right: 30px;
	opacity: 0.5;
}

191 Отступы плавающему элементу

Давайте добавим правый margin
 в этом случае текст действительно
 отодвинется от правого края картинки:

 div {
	width: 400px;
	border: 1px solid red;
	text-align: justify;
}
p {
	border: 1px solid green;
}
img {
	float: left;
	margin-right: 30px;
	opacity: 0.5;
}

Интересный эффект получится,
если добавить еще и margin абзацам
сами абзацы отодвинутся от левого
края дива-родителя, при этом текст
в них по-прежнему будет отодвинут
от правого края картинки, так как ей задан
правый margin:

div {
	width: 400px;
	border: 1px solid red;
	text-align: justify;
}
p {
	margin-left: 30px;
	border: 1px solid green;
}
img {
	float: left;
	margin-right: 30px;
	opacity: 0.5;
}

//задание//

div {
	width: 400px;
	text-align: left;
}

img {
	float: left;
	margin-right: 30px;
}
img {
	float:right;
	margin-right: 30px;
}

192 Плавающие элементы под тегами
Пусть сейчас у нас есть два абзаца и картинка,
размещенная в первом абзаце. Пусть этой картинке
у нас задано свойство float в значении right,
а также полупрозрачность:

div {
	border: 1px solid red;
	text-align: justify;
}
p {
	border: 1px solid green;
}
img {
	float: right;
	opacity: 0.5;
}

А теперь давайте поставим в HTML коде картинку
после первого абзаца и посмотрим, что будет:

div {
	border: 1px solid red;
	text-align: justify;
}
p {
	border: 1px solid green;
}
img {
	float: right;
	opacity: 0.5;
}
Давайте вообще переставим нашу картинку
после второго абзаца. В этом случае она будет
плавать справа, но никакого обтекания не будет:

div {
	border: 1px solid red;
	text-align: justify;
}
p {
	border: 1px solid green;
}
img {
	float: right;
	opacity: 0.5;
}

193 Действие флоатов на родителя

Пусть теперь у нас есть див,
в котором лежит картинка. Диву зададим границу,
а картинке пока не будем задавать свойство float.

div {
	border: 1px solid red;
}

Теперь давайте установим картинке свойство float
в значении left. В этом случае произойдет удивительная
вещь - высота родителя исчезнет, его нижняя граница
будет начинаться сразу после верхней,
а картинка вылезет снизу за своего родителя:

div {
	border: 1px solid red;
}
img {
	float: left;
}

Давайте свойству float вместо left напишем значение
right. Поведение родителя не изменится,
но картинка начнет плавать справа:

div {
	border: 1px solid red;
}
img {
	float: right;
}

194 Высота родителя флоатов
Хотя плавающие элементы не расширяют своего
родителя по высоте, мы можем сами задать ему
высоту с помощью свойства height. Сделаем это:

div {
	height: 100px;
	border: 1px solid red;
}
img {
	float: right;
}

195 Текст в родителе флоатов